<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>SARS 2019 第四周打卡（SecureJSON） · ILOFT · 我的阁楼</title><meta name="description" content="SARS 2019 第四周打卡（SecureJSON） - Yu"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://www.iloft.xyz/atom.xml" title="ILOFT · 我的阁楼"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="ILOFT · 我的阁楼" type="application/atom+xml">
</head><body><div class="wrap"><header><a class="logo-link" href="/"><img src="/logo.svg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">LOFT</a></li><li class="nav-list-item"><a class="nav-list-link" href="/archives/" target="_self">ARCHIVE</a></li><li class="nav-list-item"><a class="nav-list-link" href="/about/" target="_self">ABOUT</a></li><li class="nav-list-item"><a class="nav-list-link" href="/links/" target="_self">LINKS</a></li><li class="nav-list-item"><a class="nav-list-link" href="/atom.xml" target="_self">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">SARS 2019 第四周打卡（SecureJSON）</h1><div class="post-info">2019年9月8日</div><div class="post-content"><p>　　本周是开学周，整个工作日都在开会，学习时间并不多。周四晚上参加字节跳动的宣讲会，简单的介绍了目前字节跳动的技术栈。其中字节跳动的 http 框架使用的是 Gin，因此周六周日就捣鼓起来了，其中就遇到了一个奇怪的功能——SecureJSON。<span id="more"></span></p><p>　　根据文档描述 SecureJSON 可以防止 json 劫持，如果给定的结构是数组值，则默认预置 <code>&quot;while(1);&quot;</code> 到响应体。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">securejson</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	names := []<span class="type">string</span>&#123;<span class="string">&quot;lena&quot;</span>, <span class="string">&quot;austin&quot;</span>, <span class="string">&quot;foo&quot;</span>&#125;</span><br><span class="line">	r.GET(<span class="string">&quot;securejson&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		c.SecureJSON(http.StatusOK, names)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　运行示例代码，响应体被插入了<code>&quot;while(1);&quot;</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">λ curl http://127.0.0.1:8080/securejson</span><br><span class="line">while(1);[&quot;lena&quot;,&quot;austin&quot;,&quot;foo&quot;]</span><br></pre></td></tr></table></figure><p>　　根据文档的描述将 Array 修改成 Map。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">securejson</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.GET(<span class="string">&quot;securejson1&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		c.SecureJSON(http.StatusOK, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;names&quot;</span>: <span class="string">&quot;Yu&quot;</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　此时响应体前并未添加<code>&quot;while(1);&quot;</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">λ curl http://127.0.0.1:8080/securejson1</span><br><span class="line">&#123;&quot;names&quot;:&quot;Yu&quot;&#125;</span><br></pre></td></tr></table></figure><p>　　难道<code>[]</code>是造成的所谓 JSON 劫持的原因吗，JSON 劫持到底是什么，通过查阅资料找到了一段示例代码。<br>　　某银行可以通过某个 Get 方法的 API 获取已登录用户的账户余额。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET https<span class="punctuation">:</span><span class="comment">//mybank.com/users/balance</span></span><br><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;userName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jayden&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;balance&quot;</span><span class="punctuation">:</span> <span class="number">1200</span>    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>         <span class="attr">&quot;userName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;oscar&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;balance&quot;</span><span class="punctuation">:</span> <span class="number">1200000</span>        <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line">Cookie<span class="punctuation">:</span> XXXXXOOOXXXXX</span><br></pre></td></tr></table></figure><p>　　正常情况下 Cookie 和同源策略可以阻止 JS 跨域获取数据，那攻击者该如何获取到数据呢。在浏览器控制台实验发现以<code>[]</code>开头的 Javascript 代码可以直接执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;[1,2,3]&#x27;</span>);</span><br><span class="line"><span class="title class_">Array</span>(<span class="number">3</span>) [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ]</span><br></pre></td></tr></table></figure><p>　　也就是说如果将<code>[]</code>格式的数据放入<code>&lt;script&gt;</code>标签下可以直接被执行，即便如此又该如何获取到数据呢？这时候 Javascript 覆盖和重写特性就被利用了－如果有多个重名的函数与方法只有最后一个定义的有效。攻击者通过重写默认的<code>Array()</code>函数，并将返回<code>[]</code>格式的 API 放入<code>&lt;script&gt;</code>标签下，一旦运行到<code>[</code>就会调用覆写的<code>Array()</code>来窃取数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;<span class="keyword">function</span> <span class="title function_">Array</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> valueExtractor = <span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">      <span class="comment">// Alert the value</span></span><br><span class="line">      <span class="title function_">alert</span>(value);</span><br><span class="line">      <span class="comment">// Set the next index to use this method as well</span></span><br><span class="line">      that.<span class="title function_">__defineSetter__</span>(index.<span class="title function_">toString</span>(),valueExtractor );</span><br><span class="line">      index++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// Set the setter for item 0</span></span><br><span class="line">    that.<span class="title function_">__defineSetter__</span>(index.<span class="title function_">toString</span>(),valueExtractor );</span><br><span class="line">    index++;&#125;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://mybank.com/users/balance&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>　　主流浏览器通过删除<code>__defineSetter__</code>阻止覆写修复了该漏洞。但随着 ES6 Proxy 的发布，<code>Array()</code>又可以被覆写利用了。尽管浏览器很快修复了这些漏洞，Google、Facebook 等厂商通过在自己的 API 前添死循环阻止执行到<code>[</code>，也是为了避免今后出现其它利用方法。客户端则需要先将附加的安全头去除再进行处理。<br>　　这也是为什么 Gin 的 SecureJSON 不对<code>&#123;&#125;</code>格式的 JSON 进行处理，JS 会首先检查语法，导致<code>&#123;&#125;</code>格式的 API 无法被执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;&#123;&quot;key&quot;:&quot;value&quot;&#125;&#x27;</span>);</span><br><span class="line"><span class="title class_">SyntaxError</span>: unexpected <span class="attr">token</span>: <span class="string">&#x27;:&#x27;</span></span><br></pre></td></tr></table></figure><p>　　虽然只是一个小问题，但深入研究探究其中的缘由还是很有趣的。</p></div></article></div></main><footer><div class="paginator"><a class="prev" href="/archives/sars2019-5.html">上一篇</a><a class="next" href="/archives/sars2019-2.html">下一篇</a></div><div id="giscus"></div><script src="https://giscus.app/client.js" data-repo="myloft/blog" data-repo-id="MDEwOlJlcG9zaXRvcnk5MTQ0MTQ5Nw==" data-category="Announcements" data-category-id="DIC_kwDOBXNJWc4CT54-" data-mapping="  mapping: pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async>></script><div class="copyright"><p>© 2013 - 2025 <a href="https://www.iloft.xyz">Yu</a>, Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="/sitemap.xml" target="_blank">Sitemap</a></p><p><a href="https://beian.miit.gov.cn/" target="_blank">苏ICP备16033901号-3</a></p></div></footer></div><script>!function(e,a,t,n,g,c){e.GoogleAnalyticsObject=n,e.ga||(e.ga=function(){(e.ga.q=e.ga.q||[]).push(arguments)}),e.ga.l=+new Date,g=a.createElement(t),c=a.getElementsByTagName(t)[0],g.src="//www.google-analytics.com/analytics.js",c.parentNode.insertBefore(g,c)}(window,document,"script","ga"),ga("create","UA-89639365-1","auto"),ga("send","pageview")</script></body></html>